package Daemon112::ArrayQueue;

=head1 NAME

Daemon112::ArrayQueue - a high-performance array-based priority queue
(adapted from POE::Queue::Array under Perl 5 licence)

=head1 SYNOPSIS

Daemon112::ArrayQueue implements a priority queue using Perl arrays,
splice, and copious application of cleverness.

  #!perl

  use warnings;
  use strict;
  use Daemon112::ArrayQueue;

  my $pqa = Daemon112::ArrayQueue->new();

  # Enqueue a few items.

  foreach my $priority (505, 404, 303, 202, 101) {
    $pqa->enqueue($priority, "payload $priority");
  }

  # Dequeue until the queue is drained.

  while (1) {
    my ($priority, $queue_id, $payload) = $pqa->dequeue_next();
    last unless defined $priority;

    print(
      "dequeued id($queue_id) ",
      "priority($priority) ",
      "payload($payload)\n",
    );
  }

Sample output:

  dequeued id(5) priority(101) payload(payload 101)
  dequeued id(4) priority(202) payload(payload 202)
  dequeued id(3) priority(303) payload(payload 303)
  dequeued id(2) priority(404) payload(payload 404)
  dequeued id(1) priority(505) payload(payload 505)

=head1 DESCRIPTION

Priority queues may be implemented a number of ways, but they tend to
behave similar to lists that are kept in order by some kind of
"priority".  Enqueued items are stored such that the "next" item to be
retrieved is the one with the highest priority.  Subsequent fetches
return the next lowest priority, and so on, until the queue is
emptied.

Priority queues (also known as priority heaps) attempt to do this
while consuming the fewest resources.  Go read about it!  It's
fascinating stuff!

=head2 Daemon112::ArrayQueue Items

Daemon112::ArrayQueue items consist of three fields: A priority, a unique ID
assigned at enqueue time, and a payload.  The priority and payload are
specified by the caller, and the unique ID is generated by Daemon112::ArrayQueue
when an item is enqueued.

Daemon112::ArrayQueue imposes two limitations on priorities: Priorities must be
numeric, and lower numbers indicate higher priorities.  Aside from
that, Daemon112::ArrayQueue doesn't care what the numbers mean.

Unique IDs are handles into the queue.  Daemon112::ArrayQueue generates and
returns them as new items are enqueued.  Some methods manipulate
items, and they take IDs to identify the items to alter.

Item payloads are arbitrary application data.  Daemon112::ArrayQueue does not
examine or alter payloads itself.  Any methods that need to examine
payloads will accept a filter function. Filter functions examine
payloads so Daemon112::ArrayQueue need not.

=head1 Public Methods

=head2 new

Creates a new priority queue.  Returns a reference to the queue.

  my $queue = Daemon112::ArrayQueue->new();

=head2 enqueue PRIORITY, PAYLOAD

Enqueues a PAYLOAD, which can be just about anything that will fit
into a Perl scalar, at a particular PRIORITY level.  enqueue() returns
a unique ID which can be used to manipulate the payload or its
priority directly.

Following the UNIX tradition, lower priority numbers indicate higher
priorities.  The payload with the lowest priority number will be
dequeued first.  If two payloads have the same PRIORITY, then they
will be dequeued in the order in which they were enqueued.

In this example, a queue is used to manage a number of alarms.  The
"next" alarm will be the one due soonest.

  my $payload_id = $queue->enqueue($alarm_time, [ "stuff" ]);

=head2 dequeue_next

Removes the next item from the queue, returning it as three fields:
priority, ID and payload.

The "next" item is the one with the lowest priority number.  If
multiple items exist with the same priority, dequeue_next() will
return the one that was given the priority first.

  ITEM: while (1) {
    my ($priority, $id, $payload) = $queue->dequeue_next();
    last ITEM unless defined $priority;
    ...;
  }

=head2 get_next_priority

Returns the priority of the item at the head of the queue.  This is
the lowest numeric priority in the queue.

get_next_priority() can be useful for checking the queue to see if
it's time to dequeue some items.  In this case, the queue manages
multiple alarms, and there's nothing to do if the next alarm isn't due
yet.

  ALARM: while (1) {
    my $next_alarm_time = $queue->get_next_priority();
    last ALARM unless defined $next_alarm_time;

    if ($next_alarm_time - time() > 0) {
      sleep($next_alarm_time - time());
    }

    my ($priority, $id, $payload) = $queue->dequeue_next();
    ...;
  }

=head2 get_item_count

Returns the number of items in the queue.  It's another way to tell
whether the queue has been fully drained.  Here's an alternative
version of the example for get_next_priority().

  ALARM: while ($queue->get_item_count()) {
    my $next_alarm_time = $queue->get_next_priority();
    if ($next_alarm_time - time() > 0) {
      sleep($next_alarm_time - time());
    }

    my ($priority, $id, $payload) = $queue->dequeue_next();
    ...;
  }

=head2 remove_item ITEM_ID, FILTER_FUNCTION

Removes a single item by its ID, but only if a FILTER_FUNCTION
approves of the item's payload.

If a payload is found with the given ITEM_ID, it is passed to
FILTER_FUNCTION for examination.  If FILTER_FUNCTION returns true, the
item is removed from the queue and is returned as three fields.

  my ($priority, $id, $payload) = $queue->remove_item(
    $target_id, \&monkeys
  );

  sub monkeys {
    my $payload = shift;
    $payload->{type} eq "monkey";
  }

The returned $priority will be undef on failure, and $! will be set to
the reason why the item couldn't be removed.  That will be ESRCH if
the ITEM_ID was not found in the queue, or EPERM if the filter
function returned false.

=head2 remove_items FILTER_FUNCTION [, MAX_ITEM_COUNT ]

Removes and returns items from the queue that match a FILTER_FUNCTION.
remove_items() will return immediately if MAX_ITEM_COUNT items is
specified and that many items have been removed from the queue.
MAX_ITEM_COUNT is a bit of optimization if the application knows in
advance how many items will match the FILTER_FUNCTION.

Returns a list of items that were removed.  Each item is an array
reference containing a priority, item ID, and payload.  Returns
nothing if FILTER_FUNCTION matched nothing.

  # Remove up to 12 monkeys.
  my @monkeys = $queue->remove_items(\&monkeys, 12);
  foreach my $monkey (@monkeys) {
    my ($priority, $id, $payload) = @$monkey;
    print(
      "Removed monkey:\n",
      "  priority = $priority\n",
      "  queue id = $id\n",
      "  payload  = $payload\n",
    );
  }

There is no guarantee which items will be removed if MAX_ITEM_COUNT is
specified too low.

=head2 peek_items FILTER_FUNCTION [, MAX_ITEM_COUNT ]

peek_items() returns up to MAX_ITEM_COUNT items that match a given
FILTER_FUNCTION without removing them from the queue.

  my @entire_queue = $queue->peek_items(sub { 1 });
  foreach my $item (@entire_queue) {
    my ($priority, $id, $payload) = @$item;
    print(
      "Item:\n",
      "  priority = $priority\n",
      "  queue id = $id\n",
      "  payload  = $payload\n",
    );
  }

=head2 adjust_priority ITEM_ID, FILTER_FUNCTION, DELTA

Changes the priority of an item by DELTA.  The item is identified by
its ITEM_ID, and the change will only happen if the item's payload
satisfies a FILTER_FUNCTION.  Returns the new priority, which is the
previous priority + DELTA.  DELTA may be negative.

  my $new_priority = $queue->adjust_priority(
    $item_id, \&one_of_mine, 100
  );

  sub one_of_mine {
    my $payload = shift;
    return $payload->{owner} == $me;
  }

Returns undef if the item's priority could not be adjusted, and sets
$! to explain why: ESRCH means that the ITEM_ID could not be found,
and EPERM means that the FILTER_FUNCTION was not satisfied.

=head2 set_priority ITEM_ID, FILTER_FUNCTION, ABSOLUTE_PRIORITY

Sets an item's priority to a new ABSOLUTE_PRIORITY.  The item is
identified by its ITEM_ID, and the change will only be allowed to
happen if the item's payload satisfies a FILTER_FUNCTION.  Returns the
new priority, which should match ABSOLUTE_PRIORITY.

Returns undef if the item's priority could not be set, and sets $! to
explain why: ESRCH means that the ITEM_ID could not be found, and
EPERM means that the FILTER_FUNCTION was not satisfied.

  my $new_priority = $queue->set_priority(
    $item_id, \&one_of_mine, time() + 60
  );

  unless (defined $new_priority) {
    die "one of our submarines is missing: $item_id" if $! == ESRCH;
    die "set_priority disallowed for item $item_id" if $! == EPERM;
    die $!;
  }

  sub one_of_mine {
    $_[0]{owner} == $me;
  }

=head1 AUTHORS & COPYRIGHTS

Please see https://metacpan.org/pod/POE for more information about
POE's authors and contributors.

=cut

use strict;

use Errno qw(ESRCH EPERM);
use Carp qw(confess);

sub DEBUG () { 0 }

### Helpful offsets.

sub ITEM_PRIORITY () { 0 }
sub ITEM_ID ()       { 1 }
sub ITEM_PAYLOAD ()  { 2 }

sub import {
    my $package = caller();
    no strict 'refs';
    *{ $package . '::ITEM_PRIORITY' } = \&ITEM_PRIORITY;
    *{ $package . '::ITEM_ID' }       = \&ITEM_ID;
    *{ $package . '::ITEM_PAYLOAD' }  = \&ITEM_PAYLOAD;
}

# Item IDs are unique across all queues.

my $queue_seq = 0;
my %item_priority;

### A very simple constructor.

sub new {
    bless [], shift();
}

### Add an item to the queue.  Returns the new item's ID.

sub enqueue {
    my ( $self, $priority, $payload ) = @_;

    # Get the next item ID.  This clever loop will hang indefinitely if
    # you ever run out of integers to store things under.  Map the ID to
    # its due time for search-by-ID functions.

    my $item_id;
    1 while exists $item_priority{ $item_id = ++$queue_seq };
    $item_priority{$item_id} = $priority;

    my $item_to_enqueue = [
        $priority,    # ITEM_PRIORITY
        $item_id,     # ITEM_ID
        $payload,     # ITEM_PAYLOAD
    ];

    # Special case: No items in the queue.  The queue IS the item.
    unless (@$self) {
        $self->[0] = $item_to_enqueue;
        DEBUG and warn $self->_dump_splice(0);
        return $item_id;
    }

    # Special case: The new item belongs at the end of the queue.
    if ( $priority >= $self->[-1]->[ITEM_PRIORITY] ) {
        push @$self, $item_to_enqueue;
        DEBUG and warn $self->_dump_splice( @$self - 1 );
        return $item_id;
    }

    # Special case: The new item belongs at the head of the queue.
    if ( $priority < $self->[0]->[ITEM_PRIORITY] ) {
        unshift @$self, $item_to_enqueue;
        DEBUG and warn $self->_dump_splice(0);
        return $item_id;
    }

    # Special case: There are only two items in the queue.  This item
    # naturally belongs between them.
    if ( @$self == 2 ) {
        splice @$self, 1, 0, $item_to_enqueue;
        DEBUG and warn $self->_dump_splice(1);
        return $item_id;
    }

    # And finally we have a nontrivial queue.  Insert the item using a
    # binary seek.

    $self->_insert_item( 0, $#$self, $priority, $item_to_enqueue );
    return $item_id;
}

### Dequeue the next thing from the queue.  Returns an empty list if
### the queue is empty.  There are different flavors of this
### operation.

sub dequeue_next {
    my $self = shift;

    return unless @$self;
    my ( $priority, $id, $stuff ) = @{ shift @$self };
    delete $item_priority{$id};
    return ( $priority, $id, $stuff );
}

### Return the next item's priority, undef if the queue is empty.
# This is POE's most-called method.  We could greatly benefit from
# finding ways to reduce the number of calls.

sub get_next_priority {

    # This is Ton Hospel's optimization.
    # He measured a 4% improvement by avoiding $self.
    return ( shift->[0] || return undef )->[ITEM_PRIORITY];
}

### Return the number of items currently in the queue.

sub get_item_count {
    return scalar @{ $_[0] };
}

### Internal method to insert an item using a binary seek and splice.
### We accept the bounds as parameters because the alarm adjustment
### functions may also use it.

sub _insert_item {
    my ( $self, $lower, $upper, $priority, $item ) = @_;

    while (1) {
        my $midpoint = ( $upper + $lower ) >> 1;

        # Upper and lower bounds crossed.  Insert at the lower point.
        if ( $upper < $lower ) {
            splice @$self, $lower, 0, $item;
            DEBUG and warn $self->_dump_splice($lower);
            return;
        }

        # We're looking for a priority lower than the one at the midpoint.
        # Set the new upper point to just before the midpoint.
        if ( $priority < $self->[$midpoint]->[ITEM_PRIORITY] ) {
            $upper = $midpoint - 1;
            next;
        }

        # We're looking for a priority greater or equal to the one at the
        # midpoint.  The new lower bound is just after the midpoint.
        $lower = $midpoint + 1;
    }
}

### Internal method to find a queue item by its priority and ID.  We
### assume the priority and ID have been verified already, so the item
### must exist.  Returns the index of the item that matches the
### priority/ID pair.

sub _find_item {
    my ( $self, $id, $priority ) = @_;

    # Use a binary seek.

    my $upper = $#$self;    # Last index of @$self.
    my $lower = 0;
    while (1) {
        my $midpoint = ( $upper + $lower ) >> 1;

        # Upper and lower bounds crossed.  The lower point is aimed at an
        # element with a priority higher than our target.
        last if $upper < $lower;

        # We're looking for a priority lower than the one at the midpoint.
        # Set the new upper point to just before the midpoint.
        if ( $priority < $self->[$midpoint]->[ITEM_PRIORITY] ) {
            $upper = $midpoint - 1;
            next;
        }

        # We're looking for a priority greater or equal to the one at the
        # midpoint.  The new lower bound is just after the midpoint.
        $lower = $midpoint + 1;
    }

    # The lower index is pointing to an element with a priority higher
    # than our target.  Scan backwards until we find the item with the
    # target ID.
    while ( $lower-- >= 0 ) {
        return $lower if $self->[$lower]->[ITEM_ID] == $id;
    }

    die "should never get here... maybe the queue is out of order";
}

### Remove an item by its ID.  Takes a coderef filter, too, for
### examining the payload to be sure it really wants to leave.  Sets
### $! and returns undef on failure.

sub remove_item {
    my ( $self, $id, $filter ) = @_;

    my $priority = $item_priority{$id};
    unless ( defined $priority ) {
        $! = ESRCH;
        return;
    }

    # Find that darn item.
    my $item_index = $self->_find_item( $id, $priority );

    # Test the item against the filter.
    unless ( $filter->( $self->[$item_index]->[ITEM_PAYLOAD] ) ) {
        $! = EPERM;
        return;
    }

    # Remove the item, and return it.
    delete $item_priority{$id};
    return @{ splice @$self, $item_index, 1 };
}

### Remove items matching a filter.  Regrettably, this must scan the
### entire queue.  An optional count limits the number of items to
### remove, and it may shorten execution times.  Returns a list of
### references to priority/id/payload lists.  This is intended to
### return all the items matching the filter, and the function's
### behavior is undefined when $count is less than the number of
### matching items.

sub remove_items {
    my ( $self, $filter, $count ) = @_;
    $count = @$self unless $count;

    my @items;
    my $i = @$self;
    while ( $i-- ) {
        if ( $filter->( $self->[$i]->[ITEM_PAYLOAD] ) ) {
            my $removed_item = splice( @$self, $i, 1 );
            delete $item_priority{ $removed_item->[ITEM_ID] };
            unshift @items, $removed_item;
            last unless --$count;
        }
    }

    return @items;
}

### Adjust the priority of an item by a relative amount.  Adds $delta
### to the priority of the $id'd object (if it matches $filter), and
### moves it in the queue.

sub adjust_priority {
    my ( $self, $id, $filter, $delta ) = @_;

    my $old_priority = $item_priority{$id};
    unless ( defined $old_priority ) {
        $! = ESRCH;
        return;
    }

    # Find that darn item.
    my $item_index = $self->_find_item( $id, $old_priority );

    # Test the item against the filter.
    unless ( $filter->( $self->[$item_index]->[ITEM_PAYLOAD] ) ) {
        $! = EPERM;
        return;
    }

    # Nothing to do if the delta is zero.
    # TODO Actually we may need to ensure that the item is moved to the
    # end of its current priority bucket, since it should have "moved".
    return $self->[$item_index]->[ITEM_PRIORITY] unless $delta;

    # Remove the item, and adjust its priority.
    my $item = splice( @$self, $item_index, 1 );
    my $new_priority = $item->[ITEM_PRIORITY] += $delta;
    $item_priority{$id} = $new_priority;

    $self->_reinsert_item( $new_priority, $delta, $item_index, $item );
}

### Set the priority to a specific amount.  Replaces the item's
### priority with $new_priority (if it matches $filter), and moves it
### to the new location in the queue.

sub set_priority {
    my ( $self, $id, $filter, $new_priority ) = @_;

    my $old_priority = $item_priority{$id};
    unless ( defined $old_priority ) {
        $! = ESRCH;
        return;
    }

    # Nothing to do if the old and new priorities match.
    # TODO Actually we may need to ensure that the item is moved to the
    # end of its current priority bucket, since it should have "moved".
    return $new_priority if $new_priority == $old_priority;

    # Find that darn item.
    my $item_index = $self->_find_item( $id, $old_priority );

    # Test the item against the filter.
    unless ( $filter->( $self->[$item_index]->[ITEM_PAYLOAD] ) ) {
        $! = EPERM;
        return;
    }

    # Remove the item, and calculate the delta.
    my $item = splice( @$self, $item_index, 1 );
    my $delta = $new_priority - $old_priority;
    $item->[ITEM_PRIORITY] = $item_priority{$id} = $new_priority;

    $self->_reinsert_item( $new_priority, $delta, $item_index, $item );
}

### Sanity-check the results of an item insert.  Verify that it
### belongs where it was put.  Only called during debugging.

sub _dump_splice {
    my ( $self, $index ) = @_;
    my @return;
    my $at = $self->[$index]->[ITEM_PRIORITY];
    if ( $index > 0 ) {
        my $before = $self->[ $index - 1 ]->[ITEM_PRIORITY];
        push @return, "before($before)";
        confess "out of order: $before should be < $at" if $before > $at;
    }
    push @return, "at($at)";
    if ( $index < $#$self ) {
        my $after = $self->[ $index + 1 ]->[ITEM_PRIORITY];
        push @return, "after($after)";
        my @priorities = map { $_->[ITEM_PRIORITY] } @$self;
        confess "out of order: $at should be < $after (@priorities)"
          if ( $at >= $after );
    }
    return "@return";
}

### Reinsert an item into the queue.  It has just been removed by
### adjust_priority() or set_priority() and needs to be replaced.
### This tries to be clever by not doing more work than necessary.

sub _reinsert_item {
    my ( $self, $new_priority, $delta, $item_index, $item ) = @_;

    # Now insert it back.
    # The special cases are duplicates from enqueue().  We use the delta
    # (direction) of the move and the old item index to narrow down the
    # subsequent nontrivial insert if none of the special cases apply.

    # Special case: No events in the queue.  The queue IS the item.
    unless (@$self) {
        $self->[0] = $item;
        DEBUG and warn $self->_dump_splice(0);
        return $new_priority;
    }

    # Special case: The item belongs at the end of the queue.
    if ( $new_priority >= $self->[-1]->[ITEM_PRIORITY] ) {
        push @$self, $item;
        DEBUG and warn $self->_dump_splice( @$self - 1 );
        return $new_priority;
    }

    # Special case: The item belongs at the head of the queue.
    if ( $new_priority < $self->[0]->[ITEM_PRIORITY] ) {
        unshift @$self, $item;
        DEBUG and warn $self->_dump_splice(0);
        return $new_priority;
    }

    # Special case: There are only two items in the queue.  This item
    # naturally belongs between them.

    if ( @$self == 2 ) {
        splice @$self, 1, 0, $item;
        DEBUG and warn $self->_dump_splice(1);
        return $new_priority;
    }

    # The item has moved towards an end of the queue, but there are a
    # lot of items into which it may be inserted.  We'll binary seek.

    my ( $upper, $lower );
    if ( $delta > 0 ) {
        $upper = $#$self;       # Last index in @$self.
        $lower = $item_index;
    }
    else {
        $upper = $item_index;
        $lower = 0;
    }

    $self->_insert_item( $lower, $upper, $new_priority, $item );
    return $new_priority;
}

### Peek at items that match a filter.  Returns a list of payloads
### that match the supplied coderef.

sub peek_items {
    my ( $self, $filter, $count ) = @_;
    $count = @$self unless $count;

    my @items;
    my $i = @$self;
    while ( $i-- ) {
        if ( $filter->( $self->[$i]->[ITEM_PAYLOAD] ) ) {
            unshift @items, $self->[$i];
            last unless --$count;
        }
    }

    return @items;
}

1;
